{"ast":null,"code":"function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/*!\nWaypoints - 4.0.1\nCopyright Â© 2011-2016 Caleb Troughton\nLicensed under the MIT license.\nhttps://github.com/imakewebthings/waypoints/blob/master/licenses.txt\n*/\n(function () {\n  'use strict';\n\n  var keyCounter = 0;\n  var allWaypoints = {};\n  /* http://imakewebthings.com/waypoints/api/waypoint */\n\n  function Waypoint(options) {\n    if (!options) {\n      throw new Error('No options passed to Waypoint constructor');\n    }\n\n    if (!options.element) {\n      throw new Error('No element option passed to Waypoint constructor');\n    }\n\n    if (!options.handler) {\n      throw new Error('No handler option passed to Waypoint constructor');\n    }\n\n    this.key = 'waypoint-' + keyCounter;\n    this.options = Waypoint.Adapter.extend({}, Waypoint.defaults, options);\n    this.element = this.options.element;\n    this.adapter = new Waypoint.Adapter(this.element);\n    this.callback = options.handler;\n    this.axis = this.options.horizontal ? 'horizontal' : 'vertical';\n    this.enabled = this.options.enabled;\n    this.triggerPoint = null;\n    this.group = Waypoint.Group.findOrCreate({\n      name: this.options.group,\n      axis: this.axis\n    });\n    this.context = Waypoint.Context.findOrCreateByElement(this.options.context);\n\n    if (Waypoint.offsetAliases[this.options.offset]) {\n      this.options.offset = Waypoint.offsetAliases[this.options.offset];\n    }\n\n    this.group.add(this);\n    this.context.add(this);\n    allWaypoints[this.key] = this;\n    keyCounter += 1;\n  }\n  /* Private */\n\n\n  Waypoint.prototype.queueTrigger = function (direction) {\n    this.group.queueTrigger(this, direction);\n  };\n  /* Private */\n\n\n  Waypoint.prototype.trigger = function (args) {\n    if (!this.enabled) {\n      return;\n    }\n\n    if (this.callback) {\n      this.callback.apply(this, args);\n    }\n  };\n  /* Public */\n\n  /* http://imakewebthings.com/waypoints/api/destroy */\n\n\n  Waypoint.prototype.destroy = function () {\n    this.context.remove(this);\n    this.group.remove(this);\n    delete allWaypoints[this.key];\n  };\n  /* Public */\n\n  /* http://imakewebthings.com/waypoints/api/disable */\n\n\n  Waypoint.prototype.disable = function () {\n    this.enabled = false;\n    return this;\n  };\n  /* Public */\n\n  /* http://imakewebthings.com/waypoints/api/enable */\n\n\n  Waypoint.prototype.enable = function () {\n    this.context.refresh();\n    this.enabled = true;\n    return this;\n  };\n  /* Public */\n\n  /* http://imakewebthings.com/waypoints/api/next */\n\n\n  Waypoint.prototype.next = function () {\n    return this.group.next(this);\n  };\n  /* Public */\n\n  /* http://imakewebthings.com/waypoints/api/previous */\n\n\n  Waypoint.prototype.previous = function () {\n    return this.group.previous(this);\n  };\n  /* Private */\n\n\n  Waypoint.invokeAll = function (method) {\n    var allWaypointsArray = [];\n\n    for (var waypointKey in allWaypoints) {\n      allWaypointsArray.push(allWaypoints[waypointKey]);\n    }\n\n    for (var i = 0, end = allWaypointsArray.length; i < end; i++) {\n      allWaypointsArray[i][method]();\n    }\n  };\n  /* Public */\n\n  /* http://imakewebthings.com/waypoints/api/destroy-all */\n\n\n  Waypoint.destroyAll = function () {\n    Waypoint.invokeAll('destroy');\n  };\n  /* Public */\n\n  /* http://imakewebthings.com/waypoints/api/disable-all */\n\n\n  Waypoint.disableAll = function () {\n    Waypoint.invokeAll('disable');\n  };\n  /* Public */\n\n  /* http://imakewebthings.com/waypoints/api/enable-all */\n\n\n  Waypoint.enableAll = function () {\n    Waypoint.Context.refreshAll();\n\n    for (var waypointKey in allWaypoints) {\n      allWaypoints[waypointKey].enabled = true;\n    }\n\n    return this;\n  };\n  /* Public */\n\n  /* http://imakewebthings.com/waypoints/api/refresh-all */\n\n\n  Waypoint.refreshAll = function () {\n    Waypoint.Context.refreshAll();\n  };\n  /* Public */\n\n  /* http://imakewebthings.com/waypoints/api/viewport-height */\n\n\n  Waypoint.viewportHeight = function () {\n    return window.innerHeight || document.documentElement.clientHeight;\n  };\n  /* Public */\n\n  /* http://imakewebthings.com/waypoints/api/viewport-width */\n\n\n  Waypoint.viewportWidth = function () {\n    return document.documentElement.clientWidth;\n  };\n\n  Waypoint.adapters = [];\n  Waypoint.defaults = {\n    context: window,\n    continuous: true,\n    enabled: true,\n    group: 'default',\n    horizontal: false,\n    offset: 0\n  };\n  Waypoint.offsetAliases = {\n    'bottom-in-view': function bottomInView() {\n      return this.context.innerHeight() - this.adapter.outerHeight();\n    },\n    'right-in-view': function rightInView() {\n      return this.context.innerWidth() - this.adapter.outerWidth();\n    }\n  };\n  window.Waypoint = Waypoint;\n})();\n\n(function () {\n  'use strict';\n\n  function requestAnimationFrameShim(callback) {\n    window.setTimeout(callback, 1000 / 60);\n  }\n\n  var keyCounter = 0;\n  var contexts = {};\n  var Waypoint = window.Waypoint;\n  var oldWindowLoad = window.onload;\n  /* http://imakewebthings.com/waypoints/api/context */\n\n  function Context(element) {\n    this.element = element;\n    this.Adapter = Waypoint.Adapter;\n    this.adapter = new this.Adapter(element);\n    this.key = 'waypoint-context-' + keyCounter;\n    this.didScroll = false;\n    this.didResize = false;\n    this.oldScroll = {\n      x: this.adapter.scrollLeft(),\n      y: this.adapter.scrollTop()\n    };\n    this.waypoints = {\n      vertical: {},\n      horizontal: {}\n    };\n    element.waypointContextKey = this.key;\n    contexts[element.waypointContextKey] = this;\n    keyCounter += 1;\n\n    if (!Waypoint.windowContext) {\n      Waypoint.windowContext = true;\n      Waypoint.windowContext = new Context(window);\n    }\n\n    this.createThrottledScrollHandler();\n    this.createThrottledResizeHandler();\n  }\n  /* Private */\n\n\n  Context.prototype.add = function (waypoint) {\n    var axis = waypoint.options.horizontal ? 'horizontal' : 'vertical';\n    this.waypoints[axis][waypoint.key] = waypoint;\n    this.refresh();\n  };\n  /* Private */\n\n\n  Context.prototype.checkEmpty = function () {\n    var horizontalEmpty = this.Adapter.isEmptyObject(this.waypoints.horizontal);\n    var verticalEmpty = this.Adapter.isEmptyObject(this.waypoints.vertical);\n    var isWindow = this.element == this.element.window;\n\n    if (horizontalEmpty && verticalEmpty && !isWindow) {\n      this.adapter.off('.waypoints');\n      delete contexts[this.key];\n    }\n  };\n  /* Private */\n\n\n  Context.prototype.createThrottledResizeHandler = function () {\n    var self = this;\n\n    function resizeHandler() {\n      self.handleResize();\n      self.didResize = false;\n    }\n\n    this.adapter.on('resize.waypoints', function () {\n      if (!self.didResize) {\n        self.didResize = true;\n        Waypoint.requestAnimationFrame(resizeHandler);\n      }\n    });\n  };\n  /* Private */\n\n\n  Context.prototype.createThrottledScrollHandler = function () {\n    var self = this;\n\n    function scrollHandler() {\n      self.handleScroll();\n      self.didScroll = false;\n    }\n\n    this.adapter.on('scroll.waypoints', function () {\n      if (!self.didScroll || Waypoint.isTouch) {\n        self.didScroll = true;\n        Waypoint.requestAnimationFrame(scrollHandler);\n      }\n    });\n  };\n  /* Private */\n\n\n  Context.prototype.handleResize = function () {\n    Waypoint.Context.refreshAll();\n  };\n  /* Private */\n\n\n  Context.prototype.handleScroll = function () {\n    var triggeredGroups = {};\n    var axes = {\n      horizontal: {\n        newScroll: this.adapter.scrollLeft(),\n        oldScroll: this.oldScroll.x,\n        forward: 'right',\n        backward: 'left'\n      },\n      vertical: {\n        newScroll: this.adapter.scrollTop(),\n        oldScroll: this.oldScroll.y,\n        forward: 'down',\n        backward: 'up'\n      }\n    };\n\n    for (var axisKey in axes) {\n      var axis = axes[axisKey];\n      var isForward = axis.newScroll > axis.oldScroll;\n      var direction = isForward ? axis.forward : axis.backward;\n\n      for (var waypointKey in this.waypoints[axisKey]) {\n        var waypoint = this.waypoints[axisKey][waypointKey];\n\n        if (waypoint.triggerPoint === null) {\n          continue;\n        }\n\n        var wasBeforeTriggerPoint = axis.oldScroll < waypoint.triggerPoint;\n        var nowAfterTriggerPoint = axis.newScroll >= waypoint.triggerPoint;\n        var crossedForward = wasBeforeTriggerPoint && nowAfterTriggerPoint;\n        var crossedBackward = !wasBeforeTriggerPoint && !nowAfterTriggerPoint;\n\n        if (crossedForward || crossedBackward) {\n          waypoint.queueTrigger(direction);\n          triggeredGroups[waypoint.group.id] = waypoint.group;\n        }\n      }\n    }\n\n    for (var groupKey in triggeredGroups) {\n      triggeredGroups[groupKey].flushTriggers();\n    }\n\n    this.oldScroll = {\n      x: axes.horizontal.newScroll,\n      y: axes.vertical.newScroll\n    };\n  };\n  /* Private */\n\n\n  Context.prototype.innerHeight = function () {\n    /*eslint-disable eqeqeq */\n    if (this.element == this.element.window) {\n      return Waypoint.viewportHeight();\n    }\n    /*eslint-enable eqeqeq */\n\n\n    return this.adapter.innerHeight();\n  };\n  /* Private */\n\n\n  Context.prototype.remove = function (waypoint) {\n    delete this.waypoints[waypoint.axis][waypoint.key];\n    this.checkEmpty();\n  };\n  /* Private */\n\n\n  Context.prototype.innerWidth = function () {\n    /*eslint-disable eqeqeq */\n    if (this.element == this.element.window) {\n      return Waypoint.viewportWidth();\n    }\n    /*eslint-enable eqeqeq */\n\n\n    return this.adapter.innerWidth();\n  };\n  /* Public */\n\n  /* http://imakewebthings.com/waypoints/api/context-destroy */\n\n\n  Context.prototype.destroy = function () {\n    var allWaypoints = [];\n\n    for (var axis in this.waypoints) {\n      for (var waypointKey in this.waypoints[axis]) {\n        allWaypoints.push(this.waypoints[axis][waypointKey]);\n      }\n    }\n\n    for (var i = 0, end = allWaypoints.length; i < end; i++) {\n      allWaypoints[i].destroy();\n    }\n  };\n  /* Public */\n\n  /* http://imakewebthings.com/waypoints/api/context-refresh */\n\n\n  Context.prototype.refresh = function () {\n    /*eslint-disable eqeqeq */\n    var isWindow = this.element == this.element.window;\n    /*eslint-enable eqeqeq */\n\n    var contextOffset = isWindow ? undefined : this.adapter.offset();\n    var triggeredGroups = {};\n    var axes;\n    this.handleScroll();\n    axes = {\n      horizontal: {\n        contextOffset: isWindow ? 0 : contextOffset.left,\n        contextScroll: isWindow ? 0 : this.oldScroll.x,\n        contextDimension: this.innerWidth(),\n        oldScroll: this.oldScroll.x,\n        forward: 'right',\n        backward: 'left',\n        offsetProp: 'left'\n      },\n      vertical: {\n        contextOffset: isWindow ? 0 : contextOffset.top,\n        contextScroll: isWindow ? 0 : this.oldScroll.y,\n        contextDimension: this.innerHeight(),\n        oldScroll: this.oldScroll.y,\n        forward: 'down',\n        backward: 'up',\n        offsetProp: 'top'\n      }\n    };\n\n    for (var axisKey in axes) {\n      var axis = axes[axisKey];\n\n      for (var waypointKey in this.waypoints[axisKey]) {\n        var waypoint = this.waypoints[axisKey][waypointKey];\n        var adjustment = waypoint.options.offset;\n        var oldTriggerPoint = waypoint.triggerPoint;\n        var elementOffset = 0;\n        var freshWaypoint = oldTriggerPoint == null;\n        var contextModifier, wasBeforeScroll, nowAfterScroll;\n        var triggeredBackward, triggeredForward;\n\n        if (waypoint.element !== waypoint.element.window) {\n          elementOffset = waypoint.adapter.offset()[axis.offsetProp];\n        }\n\n        if (typeof adjustment === 'function') {\n          adjustment = adjustment.apply(waypoint);\n        } else if (typeof adjustment === 'string') {\n          adjustment = parseFloat(adjustment);\n\n          if (waypoint.options.offset.indexOf('%') > -1) {\n            adjustment = Math.ceil(axis.contextDimension * adjustment / 100);\n          }\n        }\n\n        contextModifier = axis.contextScroll - axis.contextOffset;\n        waypoint.triggerPoint = Math.floor(elementOffset + contextModifier - adjustment);\n        wasBeforeScroll = oldTriggerPoint < axis.oldScroll;\n        nowAfterScroll = waypoint.triggerPoint >= axis.oldScroll;\n        triggeredBackward = wasBeforeScroll && nowAfterScroll;\n        triggeredForward = !wasBeforeScroll && !nowAfterScroll;\n\n        if (!freshWaypoint && triggeredBackward) {\n          waypoint.queueTrigger(axis.backward);\n          triggeredGroups[waypoint.group.id] = waypoint.group;\n        } else if (!freshWaypoint && triggeredForward) {\n          waypoint.queueTrigger(axis.forward);\n          triggeredGroups[waypoint.group.id] = waypoint.group;\n        } else if (freshWaypoint && axis.oldScroll >= waypoint.triggerPoint) {\n          waypoint.queueTrigger(axis.forward);\n          triggeredGroups[waypoint.group.id] = waypoint.group;\n        }\n      }\n    }\n\n    Waypoint.requestAnimationFrame(function () {\n      for (var groupKey in triggeredGroups) {\n        triggeredGroups[groupKey].flushTriggers();\n      }\n    });\n    return this;\n  };\n  /* Private */\n\n\n  Context.findOrCreateByElement = function (element) {\n    return Context.findByElement(element) || new Context(element);\n  };\n  /* Private */\n\n\n  Context.refreshAll = function () {\n    for (var contextId in contexts) {\n      contexts[contextId].refresh();\n    }\n  };\n  /* Public */\n\n  /* http://imakewebthings.com/waypoints/api/context-find-by-element */\n\n\n  Context.findByElement = function (element) {\n    return contexts[element.waypointContextKey];\n  };\n\n  window.onload = function () {\n    if (oldWindowLoad) {\n      oldWindowLoad();\n    }\n\n    Context.refreshAll();\n  };\n\n  Waypoint.requestAnimationFrame = function (callback) {\n    var requestFn = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || requestAnimationFrameShim;\n    requestFn.call(window, callback);\n  };\n\n  Waypoint.Context = Context;\n})();\n\n(function () {\n  'use strict';\n\n  function byTriggerPoint(a, b) {\n    return a.triggerPoint - b.triggerPoint;\n  }\n\n  function byReverseTriggerPoint(a, b) {\n    return b.triggerPoint - a.triggerPoint;\n  }\n\n  var groups = {\n    vertical: {},\n    horizontal: {}\n  };\n  var Waypoint = window.Waypoint;\n  /* http://imakewebthings.com/waypoints/api/group */\n\n  function Group(options) {\n    this.name = options.name;\n    this.axis = options.axis;\n    this.id = this.name + '-' + this.axis;\n    this.waypoints = [];\n    this.clearTriggerQueues();\n    groups[this.axis][this.name] = this;\n  }\n  /* Private */\n\n\n  Group.prototype.add = function (waypoint) {\n    this.waypoints.push(waypoint);\n  };\n  /* Private */\n\n\n  Group.prototype.clearTriggerQueues = function () {\n    this.triggerQueues = {\n      up: [],\n      down: [],\n      left: [],\n      right: []\n    };\n  };\n  /* Private */\n\n\n  Group.prototype.flushTriggers = function () {\n    for (var direction in this.triggerQueues) {\n      var waypoints = this.triggerQueues[direction];\n      var reverse = direction === 'up' || direction === 'left';\n      waypoints.sort(reverse ? byReverseTriggerPoint : byTriggerPoint);\n\n      for (var i = 0, end = waypoints.length; i < end; i += 1) {\n        var waypoint = waypoints[i];\n\n        if (waypoint.options.continuous || i === waypoints.length - 1) {\n          waypoint.trigger([direction]);\n        }\n      }\n    }\n\n    this.clearTriggerQueues();\n  };\n  /* Private */\n\n\n  Group.prototype.next = function (waypoint) {\n    this.waypoints.sort(byTriggerPoint);\n    var index = Waypoint.Adapter.inArray(waypoint, this.waypoints);\n    var isLast = index === this.waypoints.length - 1;\n    return isLast ? null : this.waypoints[index + 1];\n  };\n  /* Private */\n\n\n  Group.prototype.previous = function (waypoint) {\n    this.waypoints.sort(byTriggerPoint);\n    var index = Waypoint.Adapter.inArray(waypoint, this.waypoints);\n    return index ? this.waypoints[index - 1] : null;\n  };\n  /* Private */\n\n\n  Group.prototype.queueTrigger = function (waypoint, direction) {\n    this.triggerQueues[direction].push(waypoint);\n  };\n  /* Private */\n\n\n  Group.prototype.remove = function (waypoint) {\n    var index = Waypoint.Adapter.inArray(waypoint, this.waypoints);\n\n    if (index > -1) {\n      this.waypoints.splice(index, 1);\n    }\n  };\n  /* Public */\n\n  /* http://imakewebthings.com/waypoints/api/first */\n\n\n  Group.prototype.first = function () {\n    return this.waypoints[0];\n  };\n  /* Public */\n\n  /* http://imakewebthings.com/waypoints/api/last */\n\n\n  Group.prototype.last = function () {\n    return this.waypoints[this.waypoints.length - 1];\n  };\n  /* Private */\n\n\n  Group.findOrCreate = function (options) {\n    return groups[options.axis][options.name] || new Group(options);\n  };\n\n  Waypoint.Group = Group;\n})();\n\n(function () {\n  'use strict';\n\n  var Waypoint = window.Waypoint;\n\n  function isWindow(element) {\n    return element === element.window;\n  }\n\n  function getWindow(element) {\n    if (isWindow(element)) {\n      return element;\n    }\n\n    return element.defaultView;\n  }\n\n  function NoFrameworkAdapter(element) {\n    this.element = element;\n    this.handlers = {};\n  }\n\n  NoFrameworkAdapter.prototype.innerHeight = function () {\n    var isWin = isWindow(this.element);\n    return isWin ? this.element.innerHeight : this.element.clientHeight;\n  };\n\n  NoFrameworkAdapter.prototype.innerWidth = function () {\n    var isWin = isWindow(this.element);\n    return isWin ? this.element.innerWidth : this.element.clientWidth;\n  };\n\n  NoFrameworkAdapter.prototype.off = function (event, handler) {\n    function removeListeners(element, listeners, handler) {\n      for (var i = 0, end = listeners.length - 1; i < end; i++) {\n        var listener = listeners[i];\n\n        if (!handler || handler === listener) {\n          element.removeEventListener(listener);\n        }\n      }\n    }\n\n    var eventParts = event.split('.');\n    var eventType = eventParts[0];\n    var namespace = eventParts[1];\n    var element = this.element;\n\n    if (namespace && this.handlers[namespace] && eventType) {\n      removeListeners(element, this.handlers[namespace][eventType], handler);\n      this.handlers[namespace][eventType] = [];\n    } else if (eventType) {\n      for (var ns in this.handlers) {\n        removeListeners(element, this.handlers[ns][eventType] || [], handler);\n        this.handlers[ns][eventType] = [];\n      }\n    } else if (namespace && this.handlers[namespace]) {\n      for (var type in this.handlers[namespace]) {\n        removeListeners(element, this.handlers[namespace][type], handler);\n      }\n\n      this.handlers[namespace] = {};\n    }\n  };\n  /* Adapted from jQuery 1.x offset() */\n\n\n  NoFrameworkAdapter.prototype.offset = function () {\n    if (!this.element.ownerDocument) {\n      return null;\n    }\n\n    var documentElement = this.element.ownerDocument.documentElement;\n    var win = getWindow(this.element.ownerDocument);\n    var rect = {\n      top: 0,\n      left: 0\n    };\n\n    if (this.element.getBoundingClientRect) {\n      rect = this.element.getBoundingClientRect();\n    }\n\n    return {\n      top: rect.top + win.pageYOffset - documentElement.clientTop,\n      left: rect.left + win.pageXOffset - documentElement.clientLeft\n    };\n  };\n\n  NoFrameworkAdapter.prototype.on = function (event, handler) {\n    var eventParts = event.split('.');\n    var eventType = eventParts[0];\n    var namespace = eventParts[1] || '__default';\n    var nsHandlers = this.handlers[namespace] = this.handlers[namespace] || {};\n    var nsTypeList = nsHandlers[eventType] = nsHandlers[eventType] || [];\n    nsTypeList.push(handler);\n    this.element.addEventListener(eventType, handler);\n  };\n\n  NoFrameworkAdapter.prototype.outerHeight = function (includeMargin) {\n    var height = this.innerHeight();\n    var computedStyle;\n\n    if (includeMargin && !isWindow(this.element)) {\n      computedStyle = window.getComputedStyle(this.element);\n      height += parseInt(computedStyle.marginTop, 10);\n      height += parseInt(computedStyle.marginBottom, 10);\n    }\n\n    return height;\n  };\n\n  NoFrameworkAdapter.prototype.outerWidth = function (includeMargin) {\n    var width = this.innerWidth();\n    var computedStyle;\n\n    if (includeMargin && !isWindow(this.element)) {\n      computedStyle = window.getComputedStyle(this.element);\n      width += parseInt(computedStyle.marginLeft, 10);\n      width += parseInt(computedStyle.marginRight, 10);\n    }\n\n    return width;\n  };\n\n  NoFrameworkAdapter.prototype.scrollLeft = function () {\n    var win = getWindow(this.element);\n    return win ? win.pageXOffset : this.element.scrollLeft;\n  };\n\n  NoFrameworkAdapter.prototype.scrollTop = function () {\n    var win = getWindow(this.element);\n    return win ? win.pageYOffset : this.element.scrollTop;\n  };\n\n  NoFrameworkAdapter.extend = function () {\n    var args = Array.prototype.slice.call(arguments);\n\n    function merge(target, obj) {\n      if (_typeof(target) === 'object' && _typeof(obj) === 'object') {\n        for (var key in obj) {\n          if (obj.hasOwnProperty(key)) {\n            target[key] = obj[key];\n          }\n        }\n      }\n\n      return target;\n    }\n\n    for (var i = 1, end = args.length; i < end; i++) {\n      merge(args[0], args[i]);\n    }\n\n    return args[0];\n  };\n\n  NoFrameworkAdapter.inArray = function (element, array, i) {\n    return array == null ? -1 : array.indexOf(element, i);\n  };\n\n  NoFrameworkAdapter.isEmptyObject = function (obj) {\n    /* eslint no-unused-vars: 0 */\n    for (var name in obj) {\n      return false;\n    }\n\n    return true;\n  };\n\n  Waypoint.adapters.push({\n    name: 'noframework',\n    Adapter: NoFrameworkAdapter\n  });\n  Waypoint.Adapter = NoFrameworkAdapter;\n})();","map":null,"metadata":{},"sourceType":"module"}